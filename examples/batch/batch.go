package main

import (
	"context"
	"errors"
	"fmt"
	"io"
	"os"

	pgx "github.com/jackc/pgx/v5"
	pgconn "github.com/jackc/pgx/v5/pgconn"
	pgxpool "github.com/jackc/pgx/v5/pgxpool"
)

type PgxPoolInterface interface {
	Begin(context.Context) (pgx.Tx, error)
	Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
	SendBatch(context.Context, *pgx.Batch) pgx.BatchResults
	Close()
}

type ExampleBatch struct {
	batch *pgx.Batch
	br    pgx.BatchResults
	db    PgxPoolInterface
}

func (ex *ExampleBatch) databaseSetup() (err error) {
	// Create a new table 'ledger'
	sql := `CREATE TABLE IF NOT EXISTS ledger (
		id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
		description TEXT NOT NULL,
		amount BIGINT NOT NULL);`
	_, err = ex.db.Exec(context.Background(), sql)
	return err
}

func (ex *ExampleBatch) printResults(file io.Writer) (err error) {

	// Iterate over a batch of queued queries
	for index, query := range ex.batch.QueuedQueries {

		// Read results from the current query
		rows, err := ex.br.Query()
		if err != nil {
			return fmt.Errorf("iterateResults: %s", err)
		}

		if index > 0 {
			// Print SQL field of the current query
			fmt.Fprintf(file, "%v \n", query.SQL)

			// Iterate over the selected records
			//
			var id, amount, descr = int64(0), int64(0), string("")
			_, err = pgx.ForEachRow(rows, []any{&id, &descr, &amount}, func() error {
				descr = "\"" + descr + "\""
				fmt.Fprintf(file, "- %24v, amount: %d \n", descr, amount)
				return err
			})
		}
	}

	return err
}

func (ex *ExampleBatch) requestBatch() (err error) {

	// Efficiently transmits queued queries as a single transaction.
	// After the queries are run, a BatchResults object is returned.
	//
	ex.br = ex.db.SendBatch(context.Background(), ex.batch)
	if ex.br == nil {
		return errors.New("SendBatch returns a NIL object")
	}

	return err
}

func (ex *ExampleBatch) Close() (err error) {

	// Delete all rows in table ledger
	sql := `DELETE FROM ledger ;`
	_, err = ex.db.Exec(context.Background(), sql)

	// Close batch results object
	ex.br.Close()

	// Close connection to database
	ex.db.Close()

	return err
}

func main() {

	// @NOTE: the real connection is not required for tests
	db, err := pgxpool.New(context.Background(), "postgres://postgres:password@localhost/batch")
	if err != nil {
		panic(err)
	}
	defer db.Close()

	// Setup the example
	var example = ExampleBatch{db: db, batch: &pgx.Batch{}}
	if err = example.databaseSetup(); err != nil {
		panic(err)
	}

	// Add SQL queries to the queue
	example.batch.Queue(
		`INSERT INTO ledger(description, amount) VALUES ($1, $2), ($3, $4)`,
		"first item", 1, "second item", 2)

	example.batch.Queue("SELECT * FROM ledger")
	example.batch.Queue("SELECT * FROM ledger WHERE amount = 1")

	// Send a batch request and store results
	if err = example.requestBatch(); err != nil {
		panic(err)
	}

	// Print batch result to ...
	if err = example.printResults(os.Stdout); err != nil {
		panic(err)
	}

	// Close the example
	if err = example.Close(); err != nil {
		panic(err)
	}
}
